#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

const float PI         = 3.14159265359f;
const float TWO_PI     = 2.0f * PI;
const float INV_PI     = 1.0f / PI;
const float INV_TWO_PI = 1.0f / TWO_PI;

layout(set = 0, binding = 0) uniform samplerCube environmentCubemap;

layout(set = 0, binding = 1, std430) writeonly buffer Coeffs {
    float out_sphericalHarmonicCoeffs[27];
};

layout(local_size_x = 9, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uvec2 resolution = textureSize(environmentCubemap, 0);
    vec2 invResolution = 1.0f / vec2(resolution);

    vec3 L_lm = vec3(0.0f);

    for (uint face = 0; face < 6; ++face)
    {
        for (uint ux = 0; ux < resolution.x; ++ux)
        {
            for (uint uy = 0; uy < resolution.y; ++uy)
            {
                vec2 uv = (vec2(ux, uy) + 0.5f) * invResolution;
                uv.y = 1.0f - uv.y;
                uv = 2.0f * uv - 1.0f;

                vec3 dir;
                if      (face == 0) { dir = vec3( 1.0f, uv.y, -uv.x); }
                else if (face == 1) { dir = vec3(-1.0f, uv.y,  uv.x); }
                else if (face == 2) { dir = vec3( uv.x, 1.0f, -uv.y); }
                else if (face == 3) { dir = vec3( uv.x,-1.0f,  uv.y); }
                else if (face == 4) { dir = vec3( uv.x, uv.y,  1.0f); }
                else                { dir = vec3(-uv.x, uv.y, -1.0f); }

                float Y_lm[9] = {
                    0.282095,
                    0.488603 * dir.x,
                    0.488603 * dir.z,
                    0.488603 * dir.y,
                    1.092548 * dir.x * dir.z,
                    1.092548 * dir.y * dir.z,
                    1.092548 * dir.y * dir.x,
                    0.946176 * dir.z * dir.z - 0.315392,
                    0.546274 * (dir.x * dir.x - dir.y * dir.y),
                };

                vec3 L = texture(environmentCubemap, dir).rgb;
                L_lm += L * Y_lm[gl_GlobalInvocationID.x];
            }
        }
    }

    L_lm /= float(resolution.x * resolution.y * 6);
    L_lm *= PI;

    out_sphericalHarmonicCoeffs[3 * gl_GlobalInvocationID.x + 0] = L_lm[0];
    out_sphericalHarmonicCoeffs[3 * gl_GlobalInvocationID.x + 1] = L_lm[1];
    out_sphericalHarmonicCoeffs[3 * gl_GlobalInvocationID.x + 2] = L_lm[2];
}