#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

const float PI         = 3.14159265359f;
const float TWO_PI     = 2.0f * PI;
const float INV_PI     = 1.0f / PI;
const float INV_TWO_PI = 1.0f / TWO_PI;

layout(set = 0, binding = 0) uniform samplerCube environmentCubemap;

layout(set = 0, binding = 1, std430) writeonly buffer Coeffs {
    float out_sphericalHarmonicCoeffs[27];
};

layout(local_size_x = 9, local_size_y = 1, local_size_z = 1) in;
void main()
{
    uvec2 resolution = textureSize(environmentCubemap, 0);
    vec2 invResolution = 1.0f / vec2(resolution);

    out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 0] = 0.0f;
    out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 1] = 0.0f;
    out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 2] = 0.0f;

    for (uint face = 0; face < 6; ++face)
    {
        for (uint ux = 0; ux < resolution.x; ++ux)
        {
            for (uint uy = 0; uy < resolution.y; ++uy)
            {
                vec2 uv = (vec2(ux, uy) + 0.5f) * invResolution;
                uv.y = 1.0f - uv.y;
                uv = 2.0f * uv - 1.0f;

                vec3 dir;
                if      (face == 0) { dir = vec3( 1.0f, uv.y, -uv.x); }
                else if (face == 1) { dir = vec3(-1.0f, uv.y,  uv.x); }
                else if (face == 2) { dir = vec3( uv.x, 1.0f, -uv.y); }
                else if (face == 3) { dir = vec3( uv.x,-1.0f,  uv.y); }
                else if (face == 4) { dir = vec3( uv.x, uv.y,  1.0f); }
                else                { dir = vec3(-uv.x, uv.y, -1.0f); }

                float Ylm[9] = {
                    0.282095,
                    0.488603 * dir.x,
                    0.488603 * dir.z,
                    0.488603 * dir.y,
                    1.092548 * dir.x * dir.z,
                    1.092548 * dir.y * dir.z,
                    1.092548 * dir.y * dir.x,
                    0.946176 * dir.z * dir.z - 0.315392,
                    0.546274 * (dir.x * dir.x - dir.y * dir.y),
                };

                vec3 L = texture(environmentCubemap, dir).rgb;
                vec3 Llm = L * Ylm[gl_GlobalInvocationID.x];
                out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 0] += Llm[0];
                out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 1] += Llm[1];
                out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 2] += Llm[2];

                // float Y00  = 0.282095;
                // float Y11  = 0.488603 * dir.x;
                // float Y10  = 0.488603 * dir.z;
                // float Y1_1 = 0.488603 * dir.y;
                // float Y21  = 1.092548 * dir.x * dir.z;
                // float Y2_1 = 1.092548 * dir.y * dir.z;
                // float Y2_2 = 1.092548 * dir.y * dir.x;
                // float Y20  = 0.946176 * dir.z * dir.z - 0.315392;
                // float Y22  = 0.546274 * (dir.x * dir.x - dir.y * dir.y);

                // vec3 L     = texture(environmentCubemap, dir).rgb;
                // vec3 L00   = L * Y00;
                // vec3 L11   = L * Y11;
                // vec3 L10   = L * Y10;
                // vec3 L1_1  = L * Y1_1;
                // vec3 L21   = L * Y21;
                // vec3 L2_1  = L * Y2_1;
                // vec3 L2_2  = L * Y2_2;
                // vec3 L20   = L * Y20;
                // vec3 L22   = L * Y22;

                
            }
        }
    }

    float invSampleCount = 1.0f / float(resolution.x * resolution.y * 6);

    out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 0] *= invSampleCount;
    out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 1] *= invSampleCount;
    out_sphericalHarmonicCoeffs[gl_GlobalInvocationID.x + 2] *= invSampleCount;

    // uvec2 coord = gl_GlobalInvocationID.xy;
    // if (coord.x >= resolution.x || coord.y >= resolution.y) {
    //     return;
    // }

    // vec2 uv = (vec2(coord) + 0.5f) / vec2(resolution);
    // uv.y = 1.0f - uv.y;
    // uv = 2.0f * uv - 1.0f;

    // vec3 dir;

    // uint face = gl_WorkGroupID.z;
    // if      (face == 0) { dir = vec3( 1.0f, uv.y, -uv.x); }
    // else if (face == 1) { dir = vec3(-1.0f, uv.y,  uv.x); }
    // else if (face == 2) { dir = vec3( uv.x, 1.0f, -uv.y); }
    // else if (face == 3) { dir = vec3( uv.x,-1.0f,  uv.y); }
    // else if (face == 4) { dir = vec3( uv.x, uv.y,  1.0f); }
    // else                { dir = vec3(-uv.x, uv.y, -1.0f); }

    // dir = normalize(dir);
}