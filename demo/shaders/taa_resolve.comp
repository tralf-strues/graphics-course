#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_scalar_block_layout : enable

const int GROUP_SIZE         = 8;
const int SAMPLE_BORDER      = 1;
const int SAMPLE_WINDOW_SIZE = GROUP_SIZE + 2 * SAMPLE_BORDER;

layout(set = 0, binding = 0) uniform sampler2D texPrevMotionVectors;
layout(set = 0, binding = 1) uniform sampler2D texCurrMotionVectors;
layout(set = 0, binding = 2) uniform sampler2D texHistory;
layout(set = 0, binding = 3) uniform sampler2D texCurrent;
layout(set = 0, binding = 4, rgba8) uniform writeonly image2D imgOutput;

layout(push_constant) uniform params_t
{
  uvec2 resolution;
  vec2 invResolution;
} params;

shared vec3 sharedCurrentSamples[SAMPLE_WINDOW_SIZE * SAMPLE_WINDOW_SIZE];

layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE, local_size_z = 1) in;
void main()
{
  uvec2 coord = gl_GlobalInvocationID.xy;

  /* Load samples of current texture for color clamping */
  ivec2 sampleWindowUpperLeftCoord = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy) - SAMPLE_BORDER;

  int threadIdx = int(gl_LocalInvocationIndex);
  for (int idx = threadIdx; idx < SAMPLE_WINDOW_SIZE * SAMPLE_WINDOW_SIZE; idx += GROUP_SIZE * GROUP_SIZE)
  {
    ivec2 sampleCoord = sampleWindowUpperLeftCoord + ivec2(idx % SAMPLE_WINDOW_SIZE, idx / SAMPLE_WINDOW_SIZE);
    sampleCoord = clamp(sampleCoord, ivec2(0), ivec2(params.resolution) - 1);
    sharedCurrentSamples[idx] = texelFetch(texCurrent, ivec2(sampleCoord), 0).rgb;
  }

  barrier();

  if (coord.x >= params.resolution.x || coord.y >= params.resolution.y)
  {
    return;
  }

  ivec2 localCoord = ivec2(gl_LocalInvocationID.xy) + SAMPLE_BORDER;
  int localIdx = localCoord.y * SAMPLE_WINDOW_SIZE + localCoord.x;
  vec3 currentColor = sharedCurrentSamples[localIdx];

  /* Color clamping */
  vec3 minColor = vec3(9999.0f);
  vec3 maxColor = vec3(-9999.0f);
  for (int x = -SAMPLE_BORDER; x <= SAMPLE_BORDER; ++x)
  {
    for (int y = -SAMPLE_BORDER; y <= SAMPLE_BORDER; ++y)
    {
      ivec2 localCoord = ivec2(gl_LocalInvocationID.xy) + ivec2(x, y) + SAMPLE_BORDER;
      int idx = localCoord.y * SAMPLE_WINDOW_SIZE + localCoord.x;

      minColor = min(minColor, sharedCurrentSamples[idx]);
      maxColor = max(maxColor, sharedCurrentSamples[idx]);
    }
  }

  /* Resolve with motion disocclusion */
  vec2 uv = (vec2(coord) + 0.5f) * params.invResolution;

  vec2 currentMotionVector = texelFetch(texCurrMotionVectors, ivec2(coord), 0).xy;
  vec2 prevUV = uv + currentMotionVector;

  vec2 previousMotionVector = texture(texPrevMotionVectors, prevUV).xy;
  float motionVectorDiff = length(previousMotionVector - currentMotionVector);
  float motionDisocclusion = clamp((motionVectorDiff - 0.001f) * 10.0f, 0.0f, 1.0f);

  vec3 historyColor = texture(texHistory, uv + currentMotionVector).rgb;
  historyColor = clamp(historyColor, minColor, maxColor);

  vec3 accumulation = mix(currentColor, historyColor, 0.9f);

  vec3 result = mix(accumulation, currentColor, motionDisocclusion);
  imageStore(imgOutput, ivec2(coord), vec4(result, 1.0f));
}