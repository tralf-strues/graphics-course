#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "Light.h"
#include "CameraData.h"
#include "PBR.glsl"

//==================================================================================================
// Descriptor bindings / push constants
//--------------------------------------------------------------------------------------------------
layout(set = 0, binding = 0) uniform camera_data_t
{
  CameraData camera;
};

layout(set = 1, binding = 0, rgba8) uniform writeonly image2D out_color;

layout(set = 1, binding = 1) uniform sampler2D gbufferAlbedo;
layout(set = 1, binding = 2) uniform sampler2D gbufferMetalnessRoughness;
layout(set = 1, binding = 3) uniform sampler2D gbufferWsNorm;
layout(set = 1, binding = 4) uniform sampler2D depthBuffer;
layout(set = 1, binding = 5) uniform sampler2D shadowMap;

layout(set = 1, binding = 6) uniform shadow_camera_data_t
{
  CameraData shadowCamera;
};

layout(set = 1, binding = 7, std430) readonly buffer light_data_t
{
  DirectionalLight dirLight;

  uint pointLightCount;
  uint _pad0[3];

  PointLight pointLights[];
};

layout(push_constant) uniform params_t
{
  uvec2 resolution;
  vec2 invResolution;

  float proj22;
  float proj23;
  float invProj00; // Precomputed coefficient, 1 / proj[0][0]
  float invProj11; // Precomputed coefficient, 1 / proj[1][1]
} params;
//==================================================================================================

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
  /* Getting the target image coords*/
  // TODO (tralf-strues): swizzling
  uvec2 coord = gl_GlobalInvocationID.xy;
  if (coord.x >= params.resolution.x || coord.y >= params.resolution.y) {
    return;
  }

  vec2 uv = (vec2(coord) + 0.5f) * params.invResolution;

  /* Unpacking the surface point properties */
  SurfacePoint point;

  vec4 sampledAlbedo             = texture(gbufferAlbedo, uv);
  vec4 sampledMetalnessRoughness = texture(gbufferMetalnessRoughness, uv);

  vec2 mr           = sampledMetalnessRoughness.rg;
  point.albedo      = sampledAlbedo.rgb;
  point.metalness   = mr.r;
  point.roughness   = mr.g;
  point.f0          = vec3(0.04f);
  point.f0          = mix(point.f0, point.albedo, point.metalness);

  // Position reconstruction from depth.
  // Inspired by: https://mynameismjp.wordpress.com/2010/09/05/position-from-depth-3/
  float depth       = texture(depthBuffer, uv).r;
  vec2  ndcXY       = 2.0f * uv - 1.0f;
  float vsZ         = params.proj23 / (depth - params.proj22);
  point.position    = camera.wsPos + vsZ * (camera.wsForward -
                                            camera.wsRight * ndcXY.x * params.invProj00 +
                                            camera.wsUp    * ndcXY.y * params.invProj11);

  point.normal      = texture(gbufferWsNorm, uv).xyz;
  point.normal      = normalize(255.0f / 127.0f * point.normal - 128.0f / 127.0f);
  point.toCam       = normalize(camera.wsPos - point.position);

  // Indirect lighting for now
  vec3 L0 = (point.f0 / PI) * vec3(0.3f);

  // Emission
  L0 += vec3(sampledAlbedo.a, sampledMetalnessRoughness.ba);

  /* Lighting: directional light */
  LightSample dirLightSample;
  dirLightSample.toLight    = -dirLight.direction;
  dirLightSample.halfVector = normalize(point.toCam + dirLightSample.toLight);
  dirLightSample.radiance   = dirLight.radiance;

  L0 += CalculateRadiance(point, dirLightSample);

  /* Lighting: point lights */
  for (uint i = 0; i < pointLightCount; ++i)
  {
    PointLight pointLight = pointLights[i];

    LightSample pointLightSample;
    pointLightSample.toLight    = normalize(pointLight.position - point.position);
    pointLightSample.halfVector = normalize(point.toCam + pointLightSample.toLight);
    pointLightSample.radiance   = pointLight.radiance;

    // Attenuation with the fallof exactly at the light's radius.
    // Borrowed from: https://lisyarus.github.io/blog/posts/point-light-attenuation.html
    float dist                  = length(pointLight.position - point.position) / pointLight.radius;
    float dist2                 = dist * dist;
    float numerator             = max(1.0f - dist2, 0.0f);
    numerator                  *= numerator;
    float attenuation           = numerator / (1.0f + 4.0f * dist2);
    pointLightSample.radiance  *= attenuation;

    L0 += CalculateRadiance(point, pointLightSample);
  }

  imageStore(out_color, ivec2(coord), vec4(L0, 1.0f));
}