#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "Light.h"
#include "CameraData.h"

//==================================================================================================
// PBR
//--------------------------------------------------------------------------------------------------
const float PI = 3.14159265359f;

struct SurfacePoint
{
  vec3  normal;
  vec3  position;
  vec3  toCam;

  vec3  albedo;
  float metalness;
  float roughness;
  vec3  f0;
};

struct LightSample
{
  vec3  toLight;
  vec3  halfVector;
  vec3  radiance;
};

vec3 DiffuseBRDF(SurfacePoint point, LightSample light, vec3 fresnel);
vec3 SpecularBRDF(SurfacePoint point, LightSample light, vec3 fresnel);

float NDF_TRGGX(vec3 n, vec3 h, float roughness);
vec3  FresnelSchlick(vec3 h, vec3 v, vec3 f0);
float GSF_SchlickGGX(vec3 n, vec3 v, float k);
float GSF_SmithSchlickGGX(vec3 n, vec3 v, vec3 l, float k);

vec3 CalculateRadiance(SurfacePoint point, LightSample light)
{
  // Fresnel Function
  // aka how much light is reflected
  vec3 fresnel = FresnelSchlick(light.halfVector, point.toCam, point.f0);

  vec3 BRDF     = DiffuseBRDF(point, light, fresnel) + SpecularBRDF(point, light, fresnel);
  vec3 radiance = BRDF * light.radiance * max(dot(point.normal, light.toLight), 0.0f);

  return radiance;
}

vec3 DiffuseBRDF(SurfacePoint point, LightSample light, vec3 fresnel)
{
  vec3 Kd      = (1.0f - fresnel) * (1.0f - point.metalness);
  vec3 diffuse = point.albedo / PI;

  return Kd * diffuse;
}

vec3 SpecularBRDF(SurfacePoint point, LightSample light, vec3 fresnel)
{
  // Normal Distribution Function
  // aka alignment of microfacets to the halfway vector
  float NDF                 = NDF_TRGGX(point.normal, light.halfVector, point.roughness);

  // Geometry Shadowing Function
  // aka coefficient on the amount of light, which is self-shadowed or obstructed
  float k                   = (point.roughness + 1.0f) *
                               (point.roughness + 1.0f) / 8.0f;  // Roughness remapping
  float GSF                 = GSF_SmithSchlickGGX(point.normal, point.toCam, light.toLight, k);

  // Specular part
  vec3  Ks                  = fresnel;
  float specularNumerator   = NDF * GSF;
  float specularDenominator = 4.0f *
                              max(dot(point.normal, point.toCam),   0.0f) *
                              max(dot(point.normal, light.toLight), 0.0f) +
                              0.0001f; // Used to avoid division by zero
  float specular            = specularNumerator / specularDenominator;

  return Ks * specular;
}

float NDF_TRGGX(vec3 n, vec3 h, float roughness)
{
  float ggxAlpha    = roughness * roughness;  // Apparently looks better
  float ggxAlpha2   = ggxAlpha * ggxAlpha;

  float nh          = max(dot(n, h), 0.0f);

  float numerator   = ggxAlpha2;
  float denominator = nh * nh * (ggxAlpha2 - 1.0) + 1.0;
        denominator = PI * denominator * denominator;

  return numerator / denominator;
}

vec3 FresnelSchlick(vec3 h, vec3 v, vec3 f0)
{
  return f0 + (1.0 - f0) * pow(clamp(1.0f - max(dot(h, v), 0.0f), 0.0f, 1.0f), 5.0f);
}

float GSF_SchlickGGX(vec3 n, vec3 v, float k)
{
  float nv = max(dot(n, v), 0.0f);
  return nv / (nv * (1.0f - k) + k);
}

float GSF_SmithSchlickGGX(vec3 n, vec3 v, vec3 l, float k)
{
  float shadowing   = GSF_SchlickGGX(n, l, k);
  float obstruction = GSF_SchlickGGX(n, v, k);

  return shadowing * obstruction;
}
//==================================================================================================

//==================================================================================================
// Descriptor bindings / push constants
//--------------------------------------------------------------------------------------------------
layout(set = 0, binding = 0) uniform camera_data_t
{
  CameraData camera;
};

layout(set = 1, binding = 0, rgba8) uniform writeonly image2D out_color;

layout(set = 1, binding = 1) uniform sampler2D gbufferAlbedo;
layout(set = 1, binding = 2) uniform sampler2D gbufferMetalnessRoughness;
layout(set = 1, binding = 3) uniform sampler2D gbufferWsNorm;
layout(set = 1, binding = 4) uniform sampler2D depthBuffer;
layout(set = 1, binding = 5) uniform sampler2D shadowMap;

layout(set = 1, binding = 6) uniform shadow_camera_data_t
{
  CameraData shadowCamera;
};

layout(set = 1, binding = 7, std430) readonly buffer light_data_t
{
  DirectionalLight dirLight;

  uint pointLightCount;
  uint _pad0[3];

  PointLight pointLights[];
};

layout(push_constant) uniform params_t
{
  uvec2 resolution;
  vec2 invResolution;

  float proj22;
  float proj23;
  float invProj00; // Precomputed coefficient, 1 / proj[0][0]
  float invProj11; // Precomputed coefficient, 1 / proj[1][1]
} params;
//==================================================================================================

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
  /* Getting the target image coords*/
  // TODO (tralf-strues): swizzling
  uvec2 coord = gl_GlobalInvocationID.xy;
  if (coord.x >= params.resolution.x || coord.y >= params.resolution.y) {
    return;
  }

  vec2 uv = (vec2(coord) + 0.5f) * params.invResolution;

  /* Unpacking the surface point properties */
  SurfacePoint point;

  vec4 sampledAlbedo             = texture(gbufferAlbedo, uv);
  vec4 sampledMetalnessRoughness = texture(gbufferMetalnessRoughness, uv);

  vec2 mr           = sampledMetalnessRoughness.rg;
  point.albedo      = sampledAlbedo.rgb;
  point.metalness   = mr.r;
  point.roughness   = mr.g;
  point.f0          = vec3(0.04f);
  point.f0          = mix(point.f0, point.albedo, point.metalness);

  // Position reconstruction from depth.
  // Inspired by: https://mynameismjp.wordpress.com/2010/09/05/position-from-depth-3/
  float depth       = texture(depthBuffer, uv).r;
  vec2  ndcXY       = 2.0f * uv - 1.0f;
  float vsZ         = params.proj23 / (depth - params.proj22);
  point.position    = camera.wsPos + vsZ * (camera.wsForward -
                                            camera.wsRight * ndcXY.x * params.invProj00 +
                                            camera.wsUp    * ndcXY.y * params.invProj11);

  point.normal      = texture(gbufferWsNorm, uv).xyz;
  point.normal      = normalize(255.0f / 127.0f * point.normal - 128.0f / 127.0f);
  point.toCam       = normalize(camera.wsPos - point.position);

  // Indirect lighting for now
  vec3 L0 = (point.f0 / PI) * vec3(0.3f);

  // Emission
  L0 += vec3(sampledAlbedo.a, sampledMetalnessRoughness.ba);

  /* Lighting: directional light */
  LightSample dirLightSample;
  dirLightSample.toLight    = -dirLight.direction;
  dirLightSample.halfVector = normalize(point.toCam + dirLightSample.toLight);
  dirLightSample.radiance   = dirLight.radiance;

  L0 += CalculateRadiance(point, dirLightSample);

  /* Lighting: point lights */
  for (uint i = 0; i < pointLightCount; ++i)
  {
    PointLight pointLight = pointLights[i];

    LightSample pointLightSample;
    pointLightSample.toLight    = normalize(pointLight.position - point.position);
    pointLightSample.halfVector = normalize(point.toCam + pointLightSample.toLight);
    pointLightSample.radiance   = pointLight.radiance;

    // Attenuation with the fallof exactly at the light's radius.
    // Borrowed from: https://lisyarus.github.io/blog/posts/point-light-attenuation.html
    float dist                  = length(pointLight.position - point.position) / pointLight.radius;
    float dist2                 = dist * dist;
    float numerator             = max(1.0f - dist2, 0.0f);
    numerator                  *= numerator;
    float attenuation           = numerator / (1.0f + 4.0f * dist2);
    pointLightSample.radiance  *= attenuation;

    L0 += CalculateRadiance(point, pointLightSample);
  }

  imageStore(out_color, ivec2(coord), vec4(L0, 1.0f));
}